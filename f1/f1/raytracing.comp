#version 430
layout(local_size_x = 16, local_size_y = 16) in;
layout(rgba32f, binding = 0) uniform image2D outputImage;

uniform vec3 cameraPos = vec3(0.0, 0.0, 3.0);
uniform vec3 cameraDir = vec3(0.0, 0.0, -1.0);

struct Ray {
    vec3 origin;
    vec3 direction;
};

struct Sphere {
    vec3 center;
    float radius;
    vec3 color;
};

struct Cube {
    vec3 minCorner;
    vec3 maxCorner;
    vec3 color;
};

// Сцена: 1 сфера + 1 куб
Sphere sphere = Sphere(vec3(0.0, 0.0, -1.0), 0.5, vec3(0.8, 0.3, 0.3));
Cube cube = Cube(vec3(-0.3, -0.3, -1.5), vec3(0.3, 0.3, -0.9), vec3(0.3, 0.8, 0.3));

// Проверка пересечения луча со сферой
bool intersectSphere(Ray ray, Sphere s, out float t) {
    vec3 oc = ray.origin - s.center;
    float a = dot(ray.direction, ray.direction);
    float b = 2.0 * dot(oc, ray.direction);
    float c = dot(oc, oc) - s.radius * s.radius;
    float discr = b * b - 4.0 * a * c;

    if (discr < 0.0) return false;
    t = (-b - sqrt(discr)) / (2.0 * a);
    return t > 0.0;
}

// Проверка пересечения луча с кубом (AABB)
bool intersectCube(Ray ray, Cube c, out float t) {
    vec3 invDir = 1.0 / ray.direction;
    vec3 t1 = (c.minCorner - ray.origin) * invDir;
    vec3 t2 = (c.maxCorner - ray.origin) * invDir;
    vec3 tmin = min(t1, t2);
    vec3 tmax = max(t1, t2);

    float tNear = max(max(tmin.x, tmin.y), tmin.z);
    float tFar = min(min(tmax.x, tmax.y), tmax.z);

    if (tNear > tFar || tFar < 0.0) return false;
    t = tNear;
    return true;
}

void main() {
    ivec2 pixel = ivec2(gl_GlobalInvocationID.xy);
    ivec2 size = imageSize(outputImage);
    if (pixel.x >= size.x || pixel.y >= size.y) return;

    // Генерация луча из камеры
    float aspect = float(size.x) / float(size.y);
    vec2 uv = (vec2(pixel) + 0.5) / vec2(size);
    uv = uv * 2.0 - 1.0;
    uv.x *= aspect;

    Ray ray;
    ray.origin = cameraPos;
    ray.direction = normalize(vec3(uv, -1.0));

    // Трассировка
    float tSphere, tCube;
    bool hitSphere = intersectSphere(ray, sphere, tSphere);
    bool hitCube = intersectCube(ray, cube, tCube);

    vec3 color = vec3(0.1, 0.1, 0.2); // Фон

    if (hitSphere && (!hitCube || tSphere < tCube)) {
        color = sphere.color;
    } else if (hitCube) {
        color = cube.color;
    }

    imageStore(outputImage, pixel, vec4(color, 1.0));
}